1
思路：利用快速选择算法找到第k大，遍历数组找到大于等于k的。利用BFPRT算法算法的思路寻找
时间复杂度：O(n+mlog⁡m)，在mm远小于nn的情况下，可以简化为O(n)O(n)。
空间复杂度：O(m)

进阶思考
BFPRT算法求解TOPK问题已经是非常快的解法，在快速选择算法O（n）复杂情况下避免了极端情况下退化为O（n2）。
不过上述实现仍有一定问题。上述完全采用递归方法解决，在数据量过大时可能栈溢出。可以记录递归深度，在深度过深时采用小顶堆，堆排序选择第n大。枢轴的选取在数据量小时也可采用三数取中的简单方案。

2.思路：遍历数组，optLeft记录全部高度最早的出现位置，遍历optLeft，计算i为右边时的面积。易得较低高度但索引靠前的left被较高高度left超过后以后一直会被超过，从optLeft删除。
时间复杂度：O(n);
空间复杂度：平均接近O（1），最坏（N）（几乎不可能）

2.1进阶思考
修改CalRectArea即可 return ((float)heights[left]+heights[right]+/*此处修改*/tempheight)/2*(right-left);
2.2 不作特殊处理，不影响结果

3.1
思路：动态规划
时间复杂度：O(n);
空间复杂度：O(n):可以用滑动窗口优化到O（1）；

进阶思考
修改原有的动态规划方法，增加一个新的维度来记录是否已经使用了魔法钥匙。
dp[i, 1] = Math.Max(dp[i-1, 1], dp[i-2, 0] + treasures[i] + treasures[i-1])
3.2
算法遇到负值会把dp[i-1]的值拷贝到dp[i],不会出错


4思路二分，每次排除k/2的数
时间复杂度：O(log⁡k)O(logk)，其中k=n+m+12k=2n+m+1​。
空间复杂度：O(log⁡k)O(logk)，主要是由于递归调用栈

进阶思考
4.1,
纪录最后一次递归start1，start2。插入只执行最后一次递归，不过k要+1；
删除则把同样利用start1，start2找到上一个数，不过代码要修改更多。
4.2
修改代码，每次递归排除k/n的数据。


